<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>云原生流水线 Argo Workflow 的安装、使用以及个人体验 - Ryan4Yin's Space</title><meta name=Description content="Ryan4Yin's Space"><meta property="og:title" content="云原生流水线 Argo Workflow 的安装、使用以及个人体验"><meta property="og:description" content="注意：这篇文章并不是一篇入门教程，学习 Argo Workflow 请移步官方文档 Argo Documentation

Argo Workflow 是一个云原生工作流引擎，专注于编排并行任务。它的特点如下："><meta property="og:type" content="article"><meta property="og:url" content="https://ryan4yin.space/posts/expirence-of-argo-workflow/"><meta property="og:image" content="https://ryan4yin.space/posts/expirence-of-argo-workflow/argo-workflow.png"><meta property="article:published_time" content="2021-01-27T15:37:27+08:00"><meta property="article:modified_time" content="2021-01-27T15:37:27+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ryan4yin.space/posts/expirence-of-argo-workflow/argo-workflow.png"><meta name=twitter:title content="云原生流水线 Argo Workflow 的安装、使用以及个人体验"><meta name=twitter:description content="注意：这篇文章并不是一篇入门教程，学习 Argo Workflow 请移步官方文档 Argo Documentation

Argo Workflow 是一个云原生工作流引擎，专注于编排并行任务。它的特点如下："><meta name=application-name content="Ryan4Yin's Space"><meta name=apple-mobile-web-app-title content="Ryan4Yin's Space"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://ryan4yin.space/posts/expirence-of-argo-workflow/><link rel=prev href=https://ryan4yin.space/posts/expirence-of-vault/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><meta name=google-site-verification content="E8bpp1lVVlb9YnSJcUzPL1dLAG17Nl_sp5Ru9a8tUDQ"><meta name=baidu-site-verification content="code-ZZtDruAnX1"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"云原生流水线 Argo Workflow 的安装、使用以及个人体验","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/ryan4yin.space\/posts\/expirence-of-argo-workflow\/"},"image":[{"@type":"ImageObject","url":"https:\/\/ryan4yin.space\/posts\/expirence-of-argo-workflow\/argo-workflow.png","width":1544,"height":546}],"genre":"posts","keywords":"云原生, CI, 持续集成, 流水线","wordcount":5253,"url":"https:\/\/ryan4yin.space\/posts\/expirence-of-argo-workflow\/","datePublished":"2021-01-27T15:37:27+08:00","dateModified":"2021-01-27T15:37:27+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ryan4yin"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Ryan4Yin's Space"><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/friends/>伙伴们 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Ryan4Yin's Space"><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/friends/>伙伴们</a><a class=menu-item href=/about/>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">云原生流水线 Argo Workflow 的安装、使用以及个人体验</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>ryan4yin</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%8A%80%E6%9C%AF/><i class="far fa-folder fa-fw"></i>技术</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-27>2021-01-27</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5253 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 11 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/posts/expirence-of-argo-workflow/argo-workflow.png data-srcset="/posts/expirence-of-argo-workflow/argo-workflow.png, /posts/expirence-of-argo-workflow/argo-workflow.png 1.5x, /posts/expirence-of-argo-workflow/argo-workflow.png 2x" data-sizes=auto alt=/posts/expirence-of-argo-workflow/argo-workflow.png title=/posts/expirence-of-argo-workflow/argo-workflow.png></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#一argo-workflow-对比-jenkins>一、Argo Workflow 对比 Jenkins</a><ul><li><a href=#1-workflow-的重用---workflowtemplate>1. Workflow 的重用 - WorkflowTemplate</a></li><li><a href=#2-workflow-的编排>2. Workflow 的编排</a></li><li><a href=#3-web-ui>3. Web UI</a></li><li><a href=#4-workflow-的分类>4. Workflow 的分类</a><ul><li><a href=#为何需要对-workflow-做细致的分类>为何需要对 Workflow 做细致的分类</a></li><li><a href=#argo-workflow-的分类能力>Argo Workflow 的分类能力</a></li></ul></li><li><a href=#5-触发构建的方式>5. 触发构建的方式</a></li><li><a href=#6-secrets-管理>6. secrets 管理</a></li><li><a href=#7-artifacts>7. Artifacts</a></li><li><a href=#8-容器镜像的构建>8. 容器镜像的构建</a></li><li><a href=#9-客户端sdk>9. 客户端/SDK</a></li></ul></li><li><a href=#二安装-argo-workflowhttpsargoprojgithubioargoinstallation>二、<a href=https://argoproj.github.io/argo/installation/>安装 Argo Workflow</a></a><ul><li><a href=#serviceaccount-配置httpsargoprojgithubioargoservice-accounts><a href=https://argoproj.github.io/argo/service-accounts/>ServiceAccount 配置</a></a></li><li><a href=#workflow-executorshttpsargoprojgithubioargoworkflow-executors><a href=https://argoproj.github.io/argo/workflow-executors/>Workflow Executors</a></a></li></ul></li><li><a href=#三使用-argo-workflow-做-ci-工具>三、使用 Argo Workflow 做 CI 工具</a></li><li><a href=#四常见问题>四、常见问题</a><ul><li><a href=#1-workflow-默认使用-root-账号>1. workflow 默认使用 root 账号？</a></li><li><a href=#2-如何从-hashicorp-vault-中读取-secrets>2. 如何从 hashicorp vault 中读取 secrets?</a></li><li><a href=#3-如何在多个名字空间中使用同一个-secrets>3. 如何在多个名字空间中使用同一个 secrets?</a></li><li><a href=#4-argo-对-cr-资源的验证不够严谨写错了-key-都不报错>4. Argo 对 CR 资源的验证不够严谨，写错了 key 都不报错</a></li><li><a href=#5-是否应该尽量使用-cicd-工具提供的功能>5. 是否应该尽量使用 CI/CD 工具提供的功能？</a></li></ul></li><li><a href=#使用体验>使用体验</a></li><li><a href=#参考文档>参考文档</a></li></ul></nav></div></div><div class=content id=content><blockquote><p>注意：这篇文章并不是一篇入门教程，学习 Argo Workflow 请移步官方文档 <a href=https://argoproj.github.io/argo/ target=_blank rel="noopener noreffer">Argo Documentation</a></p></blockquote><p><a href=https://github.com/argoproj/argo/ target=_blank rel="noopener noreffer">Argo Workflow</a> 是一个云原生工作流引擎，专注于<strong>编排并行任务</strong>。它的特点如下：</p><ol><li>使用 Kubernetes 自定义资源(CR)定义工作流，其中工作流中的每个步骤都是一个容器。</li><li>将多步骤工作流建模为一系列任务，或者使用有向无环图（DAG）描述任务之间的依赖关系。</li><li>可以在短时间内轻松运行用于机器学习或数据处理的计算密集型作业。</li><li>Argo Workflow 可以看作 Tekton 的加强版，因此显然也可以通过 Argo Workflow 运行 CI/CD 流水线(Pipielines)。</li></ol><p>阿里云是 Argo Workflow 的深度使用者和贡献者，另外 Kubeflow 底层的工作流引擎也是 Argo Workflow.</p><h2 id=一argo-workflow-对比-jenkins>一、Argo Workflow 对比 Jenkins</h2><p>我们在切换到 Argo Workflow 之前，使用的 CI/CD 工具是 Jenkins，下面对 Argo Workflow 和 Jenkins 做一个比较详细的对比，
以了解 Argo Workflow 的优缺点。</p><h3 id=1-workflow-的重用---workflowtemplate>1. Workflow 的重用 - WorkflowTemplate</h3><p>将 yaml 定义中的 <code>Kind</code> 从 <code>Workflow</code> 修改为 <code>WorkflowTemplate</code>，就能得到一个 WorkflowTemplate.</p><p>WorkflowTemplate 可以被其他 Workflow 引用并触发，也可以正常传参。</p><h3 id=2-workflow-的编排>2. Workflow 的编排</h3><p>Argo Workflow 相比其他流水线项目(Jenkins/Tekton/Drone/Gitlab-CI)而言，最大的特点，就是它强大的流水线编排能力。</p><p>其他流水线项目，对流水线之间的关联性考虑得很少，基本都假设流水线都是互相独立的。</p><p>而 Argo Workflow 能够将多个 Workflows 通过 Steps/DAG 编排起来，让流水线的各个步骤按依赖顺序分批地运行。</p><p>再借助 <a href=https://argoproj.github.io/argo/workflow-templates/#referencing-other-workflowtemplates target=_blank rel="noopener noreffer">templateRef</a> 或者 <a href=https://argoproj.github.io/argo/workflow-of-workflows/ target=_blank rel="noopener noreffer">Workflow of Workflows</a>，就能实现 Workflows 的编排了。</p><p><strong>我们之所以选择 Argo Workflow 而不是 Tekton，主要就是因为 Argo 的流水线编排能力比 Tekton 强大得多。</strong>（也许是因为我们的后端中台结构比较特殊，导致我们的 CI 流水线需要具备复杂的编排能力）</p><h3 id=3-web-ui>3. Web UI</h3><p>Argo Workflow 的 Web UI 感觉还很原始。确实该支持的功能都有，但是它貌似不是面向「用户」的，功能比较底层。</p><p>它不像 Jenkins 一样，有很友好的使用界面。</p><p>另外它所有的 Workflow 都是相互独立的，没办法直观地找到一个 WorkflowTemplate 的所有构建记录，只能通过 label/namespace 进行分类，通过任务名称进行搜索。</p><p>而 Jenkins 可以很方便地看到同一个 Job 的所有构建历史。</p><h3 id=4-workflow-的分类>4. Workflow 的分类</h3><h4 id=为何需要对-workflow-做细致的分类>为何需要对 Workflow 做细致的分类</h4><p>常见的微服务项目，往往会拆分成众多 Git 仓库（微服务）进行开发，众多的 Git 仓库会使我们创建众多的 CI/CD 流水线。
如果没有任何的分类，这一大堆的流水线如何管理，就成了一个难题。</p><p>最显见的需求：前端和后端的流水线最好能区分一下，往下细分，前端的 Web 端和客户端最好也能区分，后端的业务层和中台最好也区分开来。</p><p>另外我们还希望将运维、自动化测试相关的任务也集成到这个系统中来（目前我们就是使用 Jenkins 完成运维、自动化测试任务的），
如果没有任何分类，这一大堆流水线将混乱无比。</p><h4 id=argo-workflow-的分类能力>Argo Workflow 的分类能力</h4><p>当 Workflow 越来越多的时候，如果不做分类，一堆 WorkflowTemplate 堆在一起就会显得特别混乱。（没错，我觉得 Drone 就有这个问题&mldr;）</p><p>Argo 是完全基于 Kubernetes 的，因此目前它也只能通过 namespace/labels 进行分类。</p><p>这样的分类结构和 Jenkins 的视图-文件夹体系大相径庭，目前感觉不是很好用（也可能纯粹是 Web UI 的锅）。</p><h3 id=5-触发构建的方式>5. 触发构建的方式</h3><p>Argo Workflow 的流水线有多种触发方式：</p><ul><li>手动触发：手动提交一个 Workflow，就能触发一次构建。可以通过 <a href=https://argoproj.github.io/argo/workflow-templates/#create-workflow-from-workflowtemplate-spec target=_blank rel="noopener noreffer">workflowTemplateRef</a> 直接引用一个现成的流水线模板。</li><li>定时触发：<a href=https://argoproj.github.io/argo/cron-workflows/ target=_blank rel="noopener noreffer">CronWorkflow</a></li><li>通过 Git 仓库变更触发：<a href=https://argoproj.github.io/argo/webhooks/ target=_blank rel="noopener noreffer">Argo Workflow - Webhooks</a> 支持通过 webhook 集成 github/gitlab.<ul><li>不过感觉很难用，貌似也有人通过 <a href=https://github.com/nats-io target=_blank rel="noopener noreffer">NATS</a> 之类的消息系统来触发构建(比如 Knative)，可以参考.</li><li>另外目前也不清楚 WebHook 的可靠程度如何，会不会因为宕机、断网等故障，导致 Git 仓库变更了，而 Workflow 却没触发，而且还没有任何显眼的错误通知？如果这个错误就这样藏起来了，就可能会导致很严重的问题！</li></ul></li></ul><h3 id=6-secrets-管理>6. secrets 管理</h3><p>Argo Workflow 的流水线，可以从 kubernetes secrets/configmap 中获取信息，将信息注入到环境变量中、或者以文件形式挂载到 Pod 中。</p><p>Git 私钥、Harbor 仓库凭据、CD 需要的 kubeconfig，都可以直接从 secrets/configmap 中获取到。</p><p>另外因为 Vault 很流行，也可以将 secrets 保存在 Vault 中，再通过 vault agent 将配置注入进 Pod。</p><h3 id=7-artifacts>7. Artifacts</h3><p>Argo 支持接入对象存储，做全局的 Artifact 仓库，本地可以使用 MinIO.</p><p>使用对象存储存储 Artifact，最大的好处就是可以在 Pod 之间随意传数据，Pod 可以完全分布式地运行在 Kubernetes 集群的任何节点上。</p><p>另外也可以考虑借助 Artifact 仓库实现跨流水线的缓存复用（未测试），提升构建速度。</p><h3 id=8-容器镜像的构建>8. 容器镜像的构建</h3><p>借助 Kaniko 等容器镜像构建工具，可以实现容器镜像的分布式构建。</p><p>Kaniko 对构建缓存的支持也很好，可以直接将缓存存储在容器镜像仓库中。</p><h3 id=9-客户端sdk>9. 客户端/SDK</h3><p>Argo 有提供一个命令行客户端，也有 HTTP API 可供使用。</p><p>如下项目值得试用：</p><ul><li><a href=https://github.com/argoproj-labs/argo-client-python target=_blank rel="noopener noreffer">argo-client-python</a>: Argo Workflow 的 Python 客户端</li><li><a href=https://github.com/couler-proj/couler target=_blank rel="noopener noreffer">couler</a>: 为 Argo/Tekton/Airflow 提供统一的构建与管理接口</li><li><a href=https://github.com/argoproj-labs/argo-python-dsl target=_blank rel="noopener noreffer">argo-python-dsl</a>: 使用 Python DSL 编写 Argo Workflow</li></ul><p>感觉 couler 挺不错的，可以直接用 Python 写 WorkflowTemplate，这样就一步到位，所有 CI/CD 代码全部是 Python 了。</p><p>此外，因为 argo workflow 是 kubernetes 自定义资源 CR，也可以使用 helm/kustomize 来做 workflow 的生成。</p><p>目前我们一些步骤非常多，但是重复度也很高的 Argo 流水线配置，就是使用 helm 生成的——关键数据抽取到 values.yaml 中，使用 helm 模板 + <code>range</code> 循环来生成 workflow 配置。</p><h2 id=二安装-argo-workflowhttpsargoprojgithubioargoinstallation>二、<a href=https://argoproj.github.io/argo/installation/ target=_blank rel="noopener noreffer">安装 Argo Workflow</a></h2><p>安装一个集群版(cluster wide)的 Argo Workflow，使用 MinIO 做 artifacts 存储：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo/stable/manifests/install.yaml
</code></pre></td></tr></table></div></div><p>部署 MinIO:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>helm repo add minio https://helm.min.io/ <span class=c1># official minio Helm charts</span>
<span class=c1># 查看历史版本</span>
helm search repo minio/minio -l <span class=p>|</span> head
<span class=c1># 下载并解压 chart</span>
helm pull minio/minio --untar --version 8.0.9

<span class=c1># 编写 custom-values.yaml，然后部署 minio</span>
kubectl create namespace minio
helm install minio ./minio -n argo -f custom-values.yaml
</code></pre></td></tr></table></div></div><p>minio 部署好后，它会将默认的 <code>accesskey</code> 和 <code>secretkey</code> 保存在名为 <code>minio</code> 的 secret 中。
我们需要修改 argo 的配置，将 minio 作为它的默认 artifact 仓库。</p><p>在 configmap <code>workflow-controller-configmap</code> 的 data 中添加如下字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>  artifactRepository: <span class=p>|</span>
    archiveLogs: <span class=nb>true</span>
    s3:
      bucket: argo-bucket   <span class=c1># bucket 名称，这个 bucket 需要先手动创建好！</span>
      endpoint: minio:9000  <span class=c1># minio 地址</span>
      insecure: <span class=nb>true</span>
      <span class=c1># 从 minio 这个 secret 中获取 key/secret</span>
      accessKeySecret:
        name: minio
        key: accesskey
      secretKeySecret:
        name: minio
        key: secretkey
</code></pre></td></tr></table></div></div><p>现在还差最后一步：手动进入 minio 的 Web UI，创建好 <code>argo-bucket</code> 这个 bucket.
直接访问 minio 的 9000 端口（需要使用 nodeport/ingress 等方式暴露此端口）就能进入 Web UI，使用前面提到的 secret <code>minio</code> 中的 key/secret 登录，就能创建 bucket.</p><h3 id=serviceaccount-配置httpsargoprojgithubioargoservice-accounts><a href=https://argoproj.github.io/argo/service-accounts/ target=_blank rel="noopener noreffer">ServiceAccount 配置</a></h3><p>Argo Workflow 依赖于 ServiceAccount 进行验证与授权，而且默认情况下，它使用所在 namespace 的 <code>default</code> ServiceAccount 运行 workflow.</p><p>可 <code>default</code> 这个 ServiceAccount 默认根本没有任何权限！所以 Argo 的 artifacts, outputs, access to secrets 等功能全都会因为权限不足而无法使用！</p><p>为此，Argo 的官方文档提供了两个解决方法。</p><p>方法一，直接给 default 绑定 <code>cluster-admin</code> ClusterRole，给它集群管理员的权限，只要一行命令（但是显然安全性堪忧）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kubectl create rolebinding default-admin --clusterrole<span class=o>=</span>admin --serviceaccount<span class=o>=</span>&lt;namespace&gt;:default -n &lt;namespace&gt;
</code></pre></td></tr></table></div></div><p>方法二，官方给出了<a href=https://argoproj.github.io/argo/workflow-rbac/ target=_blank rel="noopener noreffer">Argo Workflow 需要的最小权限的 Role 定义</a>，方便起见我将它改成一个 ClusterRole:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>rbac.authorization.k8s.io/v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ClusterRole</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>argo-workflow-role</span><span class=w>
</span><span class=w></span><span class=nt>rules</span><span class=p>:</span><span class=w>
</span><span class=w></span><span class=c># pod get/watch is used to identify the container IDs of the current pod</span><span class=w>
</span><span class=w></span><span class=c># pod patch is used to annotate the step&#39;s outputs back to controller (e.g. artifact location)</span><span class=w>
</span><span class=w></span>- <span class=nt>apiGroups</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=s2>&#34;&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=l>pods</span><span class=w>
</span><span class=w>  </span><span class=nt>verbs</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=l>get</span><span class=w>
</span><span class=w>  </span>- <span class=l>watch</span><span class=w>
</span><span class=w>  </span>- <span class=l>patch</span><span class=w>
</span><span class=w></span><span class=c># logs get/watch are used to get the pods logs for script outputs, and for log archival</span><span class=w>
</span><span class=w></span>- <span class=nt>apiGroups</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=s2>&#34;&#34;</span><span class=w>
</span><span class=w>  </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=l>pods/log</span><span class=w>
</span><span class=w>  </span><span class=nt>verbs</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=l>get</span><span class=w>
</span><span class=w>  </span>- <span class=l>watch</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>创建好上面这个最小的 ClusterRole，然后为每个名字空间，跑一下如下命令，给 default 账号绑定这个 clusterrole:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>kubectl create rolebinding default-argo-workflow --clusterrole<span class=o>=</span>argo-workflow-role  --serviceaccount<span class=o>=</span>&lt;namespace&gt;:default -n &lt;namespace&gt;
</code></pre></td></tr></table></div></div><p>这样就能给 default 账号提供最小的 workflow 运行权限。</p><p>或者如果你希望使用别的 ServiceAccount 来运行 workflow，也可以自行创建 ServiceAccount，然后再走上面方法二的流程，但是最后，要记得在 workflow 的 <code>spec.serviceAccountName</code> 中设定好 ServiceAccount 名称。</p><h3 id=workflow-executorshttpsargoprojgithubioargoworkflow-executors><a href=https://argoproj.github.io/argo/workflow-executors/ target=_blank rel="noopener noreffer">Workflow Executors</a></h3><p>Workflow Executor 是符合特定接口的一个进程(Process)，Argo 可以通过它执行一些动作，如监控 Pod 日志、收集 Artifacts、管理容器生命周期等等&mldr;</p><p>Workflow Executor 有多种实现，可以通过前面提到的 configmap <code>workflow-controller-configmap</code> 的 <code>containerRuntimeExecutor</code> 这个参数来选择。</p><p>可选项如下：</p><ol><li>docker(默认): 目前使用范围最广，但是安全性最差。它要求一定要挂载访问 <code>docker.sock</code>，因此一定要 root 权限！</li><li>kubelet: 应用非常少，目前功能也有些欠缺，目前也必须提供 root 权限</li><li>Kubernetes API (k8sapi): 直接通过调用 k8sapi 实现日志监控、Artifacts 手机等功能，非常安全，但是性能欠佳。</li><li>Process Namespace Sharing (pns): 安全性比 k8sapi 差一点，因为 Process 对其他所有容器都可见了。但是相对的性能好很多。</li></ol><p>在 docker 被 kubernetes 抛弃的当下，如果你已经改用 containerd 做为 kubernetes 运行时，那 argo 将会无法工作，因为它默认使用 docker 作为运行时！</p><p>我们建议将 workflow executore 改为 <code>pns</code>，兼顾安全性与性能。</p><h2 id=三使用-argo-workflow-做-ci-工具>三、使用 Argo Workflow 做 CI 工具</h2><p>官方的 Reference 还算详细，也有提供非常多的 examples 供我们参考，这里提供我们几个常用的 workflow 定义。</p><p>使用 Kaniko 构建容器镜像:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-yaml data-lang=yaml><span class=c># USAGE:</span><span class=w>
</span><span class=w></span><span class=c>#</span><span class=w>
</span><span class=w></span><span class=c># push 镜像需要一个 config.json, 这个 json 需要被挂载到 `kaniko/.docker/config.json`.</span><span class=w>
</span><span class=w></span><span class=c># 为此，你首先需要构建 config.json 文件，并使用它创建一个 kubernetes secret:</span><span class=w>
</span><span class=w></span><span class=c>#</span><span class=w>
</span><span class=w></span><span class=c>#    export DOCKER_REGISTRY=&#34;registry.svc.local&#34;</span><span class=w>
</span><span class=w></span><span class=c>#    export DOCKER_USERNAME=&lt;username&gt;</span><span class=w>
</span><span class=w></span><span class=c>#    export DOCKER_TOKEN=&#39;&lt;password&gt;&#39;   # 对于 harbor 仓库而言，token 就是账号的 password.</span><span class=w>
</span><span class=w></span><span class=c>#    kubectl create secret generic docker-config --from-literal=&#34;config.json={\&#34;auths\&#34;: {\&#34;$DOCKER_REGISTRY\&#34;: {\&#34;auth\&#34;: \&#34;$(echo -n $DOCKER_USERNAME:$DOCKER_TOKEN|base64)\&#34;}}}&#34;</span><span class=w>
</span><span class=w></span><span class=c>#</span><span class=w>
</span><span class=w></span><span class=c># clone git 仓库也需要 git credentails，这可以通过如下命令创建：</span><span class=w>
</span><span class=w></span><span class=c># </span><span class=w>
</span><span class=w></span><span class=c>#    kubectl create secret generic private-git-creds --from-literal=username=&lt;username&gt; --from-file=ssh-private-key=&lt;filename&gt;</span><span class=w>
</span><span class=w></span><span class=c># </span><span class=w>
</span><span class=w></span><span class=c># REFERENCES:</span><span class=w>
</span><span class=w></span><span class=c>#</span><span class=w>
</span><span class=w></span><span class=c># * https://github.com/argoproj/argo/blob/master/examples/buildkit-template.yaml</span><span class=w>
</span><span class=w></span><span class=c>#</span><span class=w>
</span><span class=w></span><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>argoproj.io/v1alpha1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>WorkflowTemplate</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>build-image</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>arguments</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>parameters</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>repo </span><span class=w> </span><span class=c># 源码仓库</span><span class=w>
</span><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>git@gitlab.svc.local:ryan4yin/my-app.git</span><span class=w>
</span><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>branch</span><span class=w>
</span><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>main</span><span class=w>
</span><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>context-path</span><span class=w>
</span><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dockerfile</span><span class=w>
</span><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>Dockerfile</span><span class=w>
</span><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>image </span><span class=w> </span><span class=c># 构建出的镜像名称</span><span class=w>
</span><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>registry.svc.local/ryan4yin/my-app:latest</span><span class=w>
</span><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-image</span><span class=w>
</span><span class=w>        </span><span class=c># 注意，cache-image 不能带 tag! cache 是直接通过 hash 值来索引的！</span><span class=w>
</span><span class=w>        </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=l>registry.svc.local/build-cache/my-app</span><span class=w>
</span><span class=w>  </span><span class=nt>entrypoint</span><span class=p>:</span><span class=w> </span><span class=l>main</span><span class=w>
</span><span class=w>  </span><span class=nt>templates</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>main</span><span class=w>
</span><span class=w>      </span><span class=nt>steps</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- - <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>build-image</span><span class=w>
</span><span class=w>          </span><span class=nt>template</span><span class=p>:</span><span class=w> </span><span class=l>build-image</span><span class=w>
</span><span class=w>          </span><span class=nt>arguments</span><span class=p>:</span><span class=w>
</span><span class=w>            </span><span class=nt>artifacts</span><span class=p>:</span><span class=w>
</span><span class=w>              </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>git-repo</span><span class=w>
</span><span class=w>                </span><span class=nt>git</span><span class=p>:</span><span class=w>
</span><span class=w>                  </span><span class=nt>repo</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{workflow.parameters.repo}}&#34;</span><span class=w>
</span><span class=w>                  </span><span class=nt>revision</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{workflow.parameters.branch}}&#34;</span><span class=w>
</span><span class=w>                  </span><span class=nt>insecureIgnoreHostKey</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>                  </span><span class=nt>usernameSecret</span><span class=p>:</span><span class=w>
</span><span class=w>                    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>private-git-creds</span><span class=w>
</span><span class=w>                    </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>username</span><span class=w>
</span><span class=w>                  </span><span class=nt>sshPrivateKeySecret</span><span class=p>:</span><span class=w>
</span><span class=w>                    </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>private-git-creds</span><span class=w>
</span><span class=w>                    </span><span class=nt>key</span><span class=p>:</span><span class=w> </span><span class=l>ssh-private-key</span><span class=w>
</span><span class=w>            </span><span class=nt>parameters</span><span class=p>:</span><span class=w>
</span><span class=w>              </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>context-path</span><span class=w>
</span><span class=w>                </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{workflow.parameters.context-path}}&#34;</span><span class=w>
</span><span class=w>              </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dockerfile</span><span class=w>
</span><span class=w>                </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{workflow.parameters.dockerfile}}&#34;</span><span class=w>
</span><span class=w>              </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>image</span><span class=w>
</span><span class=w>                </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{workflow.parameters.image}}&#34;</span><span class=w>
</span><span class=w>              </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-image</span><span class=w>
</span><span class=w>                </span><span class=nt>value</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{workflow.parameters.cache-image}}&#34;</span><span class=w>
</span><span class=w>    </span><span class=c># build-image 作为一个通用的 template，不应该直接去引用 workflow.xxx 中的 parameters/artifacts</span><span class=w>
</span><span class=w>    </span><span class=c># 这样做的好处是复用性强，这个 template 可以被其他 workflow 引用。</span><span class=w>
</span><span class=w>    </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>build-image</span><span class=w>
</span><span class=w>      </span><span class=nt>inputs</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>artifacts</span><span class=p>:</span><span class=w>
</span><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>git-repo</span><span class=w>
</span><span class=w>        </span><span class=nt>parameters</span><span class=p>:</span><span class=w>
</span><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>context-path</span><span class=w>
</span><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>dockerfile</span><span class=w>
</span><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>image</span><span class=w>
</span><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>cache-image</span><span class=w>
</span><span class=w>      </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>docker-config</span><span class=w>
</span><span class=w>          </span><span class=nt>secret</span><span class=p>:</span><span class=w>
</span><span class=w>            </span><span class=nt>secretName</span><span class=p>:</span><span class=w> </span><span class=l>docker-config</span><span class=w>
</span><span class=w>      </span><span class=nt>container</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>gcr.io/kaniko-project/executor:v1.3.0</span><span class=w>
</span><span class=w>        </span><span class=c># 挂载 docker credential</span><span class=w>
</span><span class=w>        </span><span class=nt>volumeMounts</span><span class=p>:</span><span class=w>
</span><span class=w>          </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>docker-config</span><span class=w>
</span><span class=w>            </span><span class=nt>mountPath</span><span class=p>:</span><span class=w> </span><span class=l>/kaniko/.docker/</span><span class=w>
</span><span class=w>        </span><span class=c># 以 context 为工作目录</span><span class=w>
</span><span class=w>        </span><span class=nt>workingDir</span><span class=p>:</span><span class=w> </span><span class=l>/work/{{inputs.parameters.context-path}}</span><span class=w>
</span><span class=w>        </span><span class=nt>args</span><span class=p>:</span><span class=w>
</span><span class=w>          </span>- --<span class=l>context=.</span><span class=w>
</span><span class=w>          </span>- --<span class=l>dockerfile={{inputs.parameters.dockerfile}}</span><span class=w>
</span><span class=w>          </span><span class=c># destination 可以重复多次，表示推送多次</span><span class=w>
</span><span class=w>          </span>- --<span class=l>destination={{inputs.parameters.image}}</span><span class=w>
</span><span class=w>          </span><span class=c># 私有镜像仓库，可以考虑不验证 tls 证书（有安全风险）</span><span class=w>
</span><span class=w>          </span>- --<span class=l>skip-tls-verify</span><span class=w>
</span><span class=w>          </span><span class=c># - --skip-tls-verify-pull</span><span class=w>
</span><span class=w>          </span><span class=c># - --registry-mirror=&lt;xxx&gt;.mirror.aliyuncs.com</span><span class=w>
</span><span class=w>          </span>- --<span class=l>reproducible</span><span class=w> </span><span class=c>#  Strip timestamps out of the image to make it reproducible</span><span class=w>
</span><span class=w>          </span><span class=c># 使用镜像仓库做远程缓存仓库</span><span class=w>
</span><span class=w>          </span>- --<span class=l>cache=true</span><span class=w>
</span><span class=w>          </span>- --<span class=l>cache-repo={{inputs.parameters.cache-image}}</span><span class=w>
</span></code></pre></td></tr></table></div></div><h2 id=四常见问题>四、常见问题</h2><h3 id=1-workflow-默认使用-root-账号>1. workflow 默认使用 root 账号？</h3><p>workflow 的流程默认使用 root 账号，如果你的镜像默认使用非 root 账号，而且要修改文件，就很可能遇到 Permission Denined 的问题。</p><p>解决方法：通过 Pod Security Context 手动设定容器的 user/group:</p><ul><li><a href=https://argoproj.github.io/argo/workflow-pod-security-context/ target=_blank rel="noopener noreffer">Workflow Pod Security Context</a></li></ul><p>安全起见，我建议所有的 workflow 都手动设定 <code>securityContext</code>，示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>argoproj.io/v1alpha1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>WorkflowTemplate</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>xxx</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>securityContext</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>runAsNonRoot</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>    </span><span class=nt>runAsUser</span><span class=p>:</span><span class=w> </span><span class=m>1000</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>或者也可以通过 <code>workflow-controller-configmap</code> 的 <code>workflowDefaults</code> 设定默认的 workflow 配置。</p><h3 id=2-如何从-hashicorp-vault-中读取-secrets>2. 如何从 hashicorp vault 中读取 secrets?</h3><blockquote><p>参考 <a href=https://github.com/argoproj/argo/issues/3267#issuecomment-650119636 target=_blank rel="noopener noreffer">Support to get secrets from Vault</a></p></blockquote><p>hashicorp vault 目前可以说是云原生领域最受欢迎的 secrets 管理工具。
我们在生产环境用它做为分布式配置中心，同时在本地 CI/CD 中，也使用它存储相关的敏感信息。</p><p>现在迁移到 argo，我们当然希望能够有一个好的方法从 vault 中读取配置。</p><p>目前最推荐的方法，是使用 vault 的 vault-agent，将 secrets 以文件的形式注入到 pod 中。</p><p>通过 valut-policy - vault-role - k8s-serviceaccount 一系列认证授权配置，可以制定非常细粒度的 secrets 权限规则，而且配置信息阅后即焚，安全性很高。</p><h3 id=3-如何在多个名字空间中使用同一个-secrets>3. 如何在多个名字空间中使用同一个 secrets?</h3><p>使用 Namespace 对 workflow 进行分类时，遇到的一个常见问题就是，如何在多个名字空间使用 <code>private-git-creds</code>/<code>docker-config</code>/<code>minio</code>/<code>vault</code> 等 workflow 必要的 secrets.</p><p>常见的方法是把 secrets 在所有名字空间 create 一次。</p><p>但是也有更方便的 secrets 同步工具：</p><p>比如，使用 <a href=https://github.com/kyverno/kyverno target=_blank rel="noopener noreffer">kyverno</a> 进行 secrets 同步的配置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>kyverno.io/v1</span><span class=w>
</span><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>ClusterPolicy</span><span class=w>
</span><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>sync-secrets</span><span class=w>
</span><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>background</span><span class=p>:</span><span class=w> </span><span class=kc>false</span><span class=w>
</span><span class=w>  </span><span class=nt>rules</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=c># 将 secret vault 从 argo Namespace 同步到其他所有 Namespace</span><span class=w>
</span><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>sync-vault-secret</span><span class=w>
</span><span class=w>    </span><span class=nt>match</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>kinds</span><span class=p>:</span><span class=w>
</span><span class=w>        </span>- <span class=l>Namespace</span><span class=w>
</span><span class=w>    </span><span class=nt>generate</span><span class=p>:</span><span class=w>
</span><span class=w>      </span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Secret</span><span class=w>
</span><span class=w>      </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>regcred</span><span class=w>
</span><span class=w>      </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;{{request.object.metadata.name}}&#34;</span><span class=w>
</span><span class=w>      </span><span class=nt>synchronize</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>      </span><span class=nt>clone</span><span class=p>:</span><span class=w>
</span><span class=w>        </span><span class=nt>namespace</span><span class=p>:</span><span class=w> </span><span class=l>argo</span><span class=w>
</span><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>vault</span><span class=w>
</span><span class=w>  </span><span class=c># 可以配置多个 rules，每个 rules 同步一个 secret</span><span class=w>
</span></code></pre></td></tr></table></div></div><p>上面提供的 kyverno 配置，会实时地监控所有 Namespace 变更，一但有新 Namespace 被创建，它就会立即将 <code>vault</code> secret 同步到该 Namespace.</p><p>或者，使用专门的 secrets/configmap 复制工具：<a href=https://github.com/mittwald/kubernetes-replicator target=_blank rel="noopener noreffer">kubernetes-replicator</a></p><h3 id=4-argo-对-cr-资源的验证不够严谨写错了-key-都不报错>4. Argo 对 CR 资源的验证不够严谨，写错了 key 都不报错</h3><p>待研究</p><h3 id=5-是否应该尽量使用-cicd-工具提供的功能>5. 是否应该尽量使用 CI/CD 工具提供的功能？</h3><p>我从同事以及网络上，了解到部分 DevOps 人员主张尽量自己使用 Python/Go 来实现 CI/CD 流水线，CI/CD 工具提供的功能能不使用就不要使用。</p><p>因此有此一问。下面做下详细的分析：</p><p>尽量使用 CI/CD 工具提供的插件/功能，好处是不需要自己去实现，可以降低维护成本。
但是相对的运维人员就需要深入学习这个 CI/CD 工具的使用，另外还会和 CI/CD 工具绑定，会增加迁移难度。</p><p>而尽量自己用 Python 等代码去实现流水线，让 CI/CD 工具只负责调度与运行这些 Python 代码，
那 CI/CD 就可以很方便地随便换，运维人员也不需要去深入学习 CI/CD 工具的使用。
缺点是可能会增加 CI/CD 代码的复杂性。</p><p>我观察到 argo/drone 的一些 examples，发现它们的特征是：</p><ol><li>所有 CI/CD 相关的逻辑，全都实现在流水线中，不需要其他构建代码</li><li>每一个 step 都使用专用镜像：golang/nodejs/python<ol><li>比如先使用 golang 镜像进行测试、构建，再使用 kaniko 将打包成容器镜像</li></ol></li></ol><p>那是否应该尽量使用 CI/CD 工具提供的功能呢？
其实这就是有多种方法实现同一件事，该用哪种方法的问题。这个问题在各个领域都很常见。</p><p>以我目前的经验来看，需要具体问题具体分析，以 argo workflow 为例：</p><ol><li>流水线本身非常简单，那完全可以直接使用 argo 来实现，没必要自己再搞个 python 脚本<ol><li>简单的流水线，迁移起来往往也非常简单。没必要为了可迁移性，非要用 argo 去调用 python 脚本。</li></ol></li><li>流水线的步骤之间包含很多逻辑判断/数据传递，那很可能是你的流水线设计有问题！<ol><li><strong>流水线的步骤之间传递的数据应该尽可能少！复杂的逻辑判断应该尽量封装在其中一个步骤中！</strong></li><li>这种情况下，就应该使用 python 脚本来封装复杂的逻辑，而不应该将这些逻辑暴露到 argo workflow 中！</li></ol></li><li>我需要批量运行很多的流水线，而且它们之间还有复杂的依赖关系：那显然应该利用上 argo wrokflow 的高级特性。<ol><li>argo 的 dag/steps 和 workflow of workflows 这两个功能结合，可以简单地实现上述功能。</li></ol></li></ol><h2 id=使用体验>使用体验</h2><p>目前已经使用 Argo Workflow 一个月多了，总的来说，最难用的就是 Web UI。</p><p>其他的都是小问题，只有 Web UI 是真的超难用，感觉根本就没有好好做过设计&mldr;</p><p>急需一个第三方 Web UI&mldr;</p><h2 id=参考文档>参考文档</h2><ul><li><a href=https://www.infoq.cn/article/fFZPvrKtbykg53x03IaH target=_blank rel="noopener noreffer">Argo加入CNCF孵化器，一文解析Kubernetes原生工作流</a></li></ul><p>视频:</p><ul><li><a href="https://www.youtube.com/watch?v=fKiU7txd4RI&list=PLj6h78yzYM2Pn8RxfLh2qrXBDftr6Qjut&index=149" target=_blank rel="noopener noreffer">How to Multiply the Power of Argo Projects By Using Them Together - Hong Wang</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-01-27</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/>云原生</a>,&nbsp;<a href=/tags/ci/>CI</a>,&nbsp;<a href=/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/>持续集成</a>,&nbsp;<a href=/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF/>流水线</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/expirence-of-vault/ class=prev rel=prev title="secrets 管理工具 Vault 的介绍、安装及使用"><i class="fas fa-angle-left fa-fw"></i>secrets 管理工具 Vault 的介绍、安装及使用</a></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.79.1">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>ryan4yin</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://ryan4yin.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":30},"comment":{},"data":{"id-1":"Ryan4Yin's Space","id-2":"Ryan4Yin's Space"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"747LJ10EI7","algoliaIndex":"ryan-space","algoliaSearchKey":"658db5f2bf056f83458cacf5dd58ec80","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":null,"speed":null}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','G-4V93QVSNFW',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-4V93QVSNFW" async></script></body></html>