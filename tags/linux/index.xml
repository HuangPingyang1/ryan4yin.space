<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Linux - 标签 - Ryan4Yin's Space</title><link>https://ryan4yin.space/tags/linux/</link><description>Linux - 标签 - Ryan4Yin's Space</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>xiaoyin_c@qq.com (ryan4yin)</managingEditor><webMaster>xiaoyin_c@qq.com (ryan4yin)</webMaster><lastBuildDate>Sun, 11 Apr 2021 16:38:13 +0800</lastBuildDate><atom:link href="https://ryan4yin.space/tags/linux/" rel="self" type="application/rss+xml"/><item><title>Linux 网络工具中的瑞士军刀 - socat &amp; netcat</title><link>https://ryan4yin.space/posts/socat-netcat/</link><pubDate>Sun, 11 Apr 2021 16:38:13 +0800</pubDate><author>
ryan4yin</author><guid>https://ryan4yin.space/posts/socat-netcat/</guid><description><![CDATA[<blockquote>
<p>本文前面部分的命令在 macOS Big Sur 和 Opensuse Tumbleweed 上测试通过，靠后的命令暂时还没测试过</p>
</blockquote>
<h2 id="socat--netcat">socat &amp; netcat</h2>
<p>netcat(network cat) 是一个历史悠久的网络工具包，被称作 TCP/IP 的瑞士军刀，各大 Linux 发行版都有默认安装 openbsd 版本的 netcat，它的命令行名称为 <code>nc</code>.</p>
<p>而 socat(socket cat)，官方文档描述它是 <code>&quot;netcat++&quot; (extended design, new implementation)</code>，项目比较活跃，kubernetes-client(kubectl) 底层就是使用的它做各种流量转发。</p>
<p>在不方便安装 socat 的环境中，我们可以使用系统自带的 netcat.
而在其他环境，可以考虑优先使用 socat.</p>
<h2 id="一简介">一、简介</h2>
<p>socat 的基本命令格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">socat <span class="o">[</span>参数<span class="o">]</span> 地址1 地址2
</code></pre></td></tr></table>
</div>
</div><p>给 socat 提供两个地址，socat 干的活就是把两个地址的流对接起来。左边地址的输出传给右边，同时又把右边地址的输出传给左边，也就是一个<strong>双向的数据管道</strong>。</p>
<p>听起来好像没啥特别的，但是实际上计算机网络干的活也就是数据传输而已，却影响了整个世界，不可小觑它的功能。</p>
<p>socat 支持非常多的地址类型：<code>-</code>/stdio，TCP, TCP-LISTEN, UDP, UDP-LISTEN, OPEN, EXEC, SOCKS, PROXY 等等，可用于端口监听、链接，文件和进程读写，代理桥接等等。</p>
<p>socat 的功能就是这么简单，命令行参数也很简洁，唯一需要花点精力学习的就是它各种地址的定义和搭配写法。</p>
<p>而 netcat 定义貌似没这么严谨，可以简单的理解为网络版的 cat 命令 2333</p>
<h2 id="二安装方法">二、安装方法</h2>
<p>各发行版都自带 netcat，包名通常为 <code>nc-openbsd</code>，因此这里只介绍 socat 的安装方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># Debian/Ubuntu</span>
sudo apt install socat

<span class="c1"># CentOS/RedHat</span>
sudo yum install socat

<span class="c1"># macOS</span>
brew install socat
</code></pre></td></tr></table>
</div>
</div><p>其他发行版基本也都可以使用包管理器安装 socat</p>
<h2 id="三常用命令">三、常用命令</h2>
<h3 id="1-网络调试">1. 网络调试</h3>
<h4 id="11-检测远程端口的可连接性确认防火墙没问题">1.1 检测远程端口的可连接性（确认防火墙没问题）</h4>
<blockquote>
<p>以前你可能学过如何用 telnet 来做这项测试，不过现在很多发行版基本都不自带 telnet 了，还需要额外安装。
telnet 差不多已经快寿终正寝了，还是建议使用更专业的 socat/netcat</p>
</blockquote>
<p>使用 socat/netcat 将 stdin 发送给一个远程端口，检测远程端口的可连接性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -d[ddd] 增加日志详细程度，-dd  Prints fatal, error, warning, and notice messages.</span>
socat -dd - TCP:192.168.1.252:3306

<span class="c1"># -v 显示详细信息</span>
<span class="c1"># -z 不发送数据，效果为立即关闭连接，快速得出结果</span>
nc -vz 192.168.1.2 <span class="m">8080</span>

<span class="c1"># -vv 显示更详细的内容</span>
<span class="c1"># -w2 超时时间设为 2 秒</span>
<span class="c1"># 使用 nc 做简单的端口扫描</span>
nc -vv -w2 -z 192.168.1.2 20-500
</code></pre></td></tr></table>
</div>
</div><h4 id="12-测试本机端口是否能正常被外部访问检测防火墙路由">1.2 测试本机端口是否能正常被外部访问（检测防火墙、路由）</h4>
<p>在本机监听一个 TCP 端口，接收到的内容传到 stdout，同时将 stdin 的输入传给客户端：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端启动命令，socat/nc 二选一</span>
socat TCP-LISTEN:7000 -
<span class="c1"># -l --listening</span>
nc -l <span class="m">7000</span>

<span class="c1"># 客户端连接命令，socat/nc 二选一</span>
socat TCP:192.168.31.123:7000 -
nc 192.168.11.123 <span class="m">7000</span>
</code></pre></td></tr></table>
</div>
</div><p>UDP 协议的测试也非常类似，使用 netcat 的示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端，只监听 ipv4</span>
nc -u -l <span class="m">8080</span>

<span class="c1"># 客户端</span>
nc -u 192.168.31.123 <span class="m">8080</span>
<span class="c1"># 客户端本机测试，注意 localhost 会被优先解析为 ipv6! 这会导致服务端(ipv4)的 nc 接收不到数据！</span>
nc -u localhost <span class="m">8080</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 socat 的 UDP 测试示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">socat UDP-LISTEN:7000 -

socat UDP:192.168.31.123:7000 -
</code></pre></td></tr></table>
</div>
</div><h4 id="13-调试-tls-协议">1.3 调试 TLS 协议</h4>
<p>模拟一个 mTLS 服务器，监听 4433 端口，接收到的数据同样输出到 stdout：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 服务端启动命令</span>
socat openssl-listen:4433,reuseaddr,cert<span class="o">=</span><span class="nv">$HOME</span>/cert/server.pem,cafile<span class="o">=</span><span class="nv">$HOME</span>/cert/client.crt -

<span class="c1"># 客户端连接命令</span>
socat - openssl-connect:192.168.31.123:4433,cert<span class="o">=</span><span class="nv">$HOME</span>/cert/client.pem,cafile<span class="o">=</span><span class="nv">$HOME</span>/cert/server.crt 
</code></pre></td></tr></table>
</div>
</div><p>上面的命令使用了 mTLS 双向认证的协议，你也可以把客户端证书去掉，这样就是普通的 TLS 协议服务器了。</p>
<h2 id="2-数据传输">2. 数据传输</h2>
<p>通常传输文件时，我都习惯使用 scp/ssh/rsync，但是 socat 其实也可以传输文件。</p>
<p>以将 demo.tar.gz 从主机 A 发送到主机 B 为例，
首先在数据发送方 A 执行如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># -u 表示数据只从左边的地址单向传输给右边（socat 默认是一个双向管道）</span>
<span class="c1"># -U 和 -u 相反，数据只从右边单向传输给左边</span>
socat -u open:demo.tar.gz tcp-listen:2000,reuseaddr
</code></pre></td></tr></table>
</div>
</div><p>然后在数据接收方 B 执行如下命令，就能把文件接收到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">socat -u tcp:192.168.1.252:2000 open:demo.tar.gz,create
</code></pre></td></tr></table>
</div>
</div><p>使用 netcat 也可以实现数据传输：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 先在接收方启动服务端</span>
nc -l -p <span class="m">8080</span> &gt; demo.tar.gz
<span class="c1"># 再在发送方启动客户端发送数据</span>
nc 192.168.1.2 <span class="m">8080</span> &lt; demo.tar.gz
</code></pre></td></tr></table>
</div>
</div><h2 id="3-担当临时的-web-服务器">3. 担当临时的 web 服务器</h2>
<p>使用 <code>fork</code> <code>reuseaddr</code> <code>SYSTEM</code> 三个命令，再用 <code>systemd</code>/<code>supervisor</code> 管理一下，就可以用几行命令实现一个简单的后台服务器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">socat TCP-LISTEN:8080,fork,reuseaddr SYSTEM:<span class="s2">&#34;python3 web.py&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的命令将监听 8080 端口，并将数据流和 web.py 的 stdio 连接起来，可以直接使用浏览器访问 <code>http://&lt;ip&gt;:8080</code> 来查看效果。</p>
<h2 id="4-端口转发">4. 端口转发</h2>
<p>监听 8080 端口，建立该端口与 <code>baidu.com:80</code> 之间的双向管道:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">socat TCP-LISTEN:8080,fork,reuseaddr  TCP:baidu.com:80
</code></pre></td></tr></table>
</div>
</div><p>拿 curl 命令测试一下，应该能正常访问到百度：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 注意指定 Host</span>
curl -v -H <span class="s1">&#39;Host: baidu.com&#39;</span> localhost:8080
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/347722248" target="_blank" rel="noopener noreferrer">新版瑞士军刀：socat - 韦易笑 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83959309" target="_blank" rel="noopener noreferrer">用好你的瑞士军刀/netcat - 韦易笑 - 知乎</a></li>
<li><a href="http://www.dest-unreach.org/socat/" target="_blank" rel="noopener noreferrer">socat - Multipurpose relay</a></li>
</ul>
]]></description></item><item><title>openSUSE 使用指南</title><link>https://ryan4yin.space/posts/opensuse-instruction/</link><pubDate>Mon, 04 Jan 2021 08:42:21 +0800</pubDate><author>
ryan4yin</author><guid>https://ryan4yin.space/posts/opensuse-instruction/</guid><description><![CDATA[<p>openSUSE 是一个基于 RPM 的发行版，这和 RHEL/CentOS 一致。
但是它的官方包管理器是专有的 zypper，挺好用的，软件也很新。</p>
<p>我最近从 <a href="https://ryan4yin.space/posts/manjaro-instruction/" rel="">Manjaro</a> 切换到了 openSUSE，发现 KDE 桌面确实比 Manjaro 更丝滑，而且社区源 OBS 体验下来比 AUR 更舒服。</p>
<p>尤其是容器/Kubernetes 方面，源里面的东西比 AUR 更丰富，而且是官方维护的。
本文算是对迁移流程做的一个总结。</p>
<blockquote>
<p>本文以 openSUSE Tumbleweed 为基础编写，这是一个和 Manjaro/Arch 一样的滚动发行版，软件源都很新。
openSUSE 社区的大部分用户都是使用的 Tumbleweed.
它的硬件兼容性也要比 openSUSE Leap（稳定版）好——实测小米游戏本安装 Leap，休眠后 Touchpad 会失灵。</p>
</blockquote>
<h2 id="一zypper-的基础命令">一、zypper 的基础命令</h2>
<p>zypper 的源在国内比较慢，但实际上下载的时候，zypper 会智能选择最快的镜像源下载软件包，比如国内的清华源等。</p>
<p>但是我发现官方的源索引更新太慢，甚至经常失败。因此没办法，还是得手动设置镜像源：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 禁用原有的官方软件源</span>
sudo zypper mr --disable repo-oss repo-non-oss repo-update repo-update-non-oss repo-debug
<span class="c1"># 添加北外镜像源，注意单引号不能省略！</span>
sudo zypper ar -fcg https://mirrors.bfsu.edu.cn/opensuse/tumbleweed/repo/oss/ bfsu-oss
sudo zypper ar -fcg https://mirrors.bfsu.edu.cn/opensuse/tumbleweed/repo/non-oss/ bfsu-non-oss
</code></pre></td></tr></table>
</div>
</div><p>然后就是 zypper 的常用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sudo zypper refresh  <span class="c1"># refresh all repos</span>
sudo zypper update   <span class="c1"># update all softwares</span>

sudo zypper search --installed-only  &lt;package-name&gt;  <span class="c1"># 查找本地安装的程序</span>
sudo zypper search &lt;package-name&gt;  <span class="c1"># 查找本地和软件源中的程序</span>

sudo zypper install &lt;package-name&gt;  <span class="c1"># 安装程序</span>
sudo zypper remove &lt;package-name&gt;  <span class="c1"># 卸载程序</span>

sudo zypper clean  <span class="c1"># 清理本地的包缓存</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="install-softwares">Install Softwares</h2>
<blockquote>
<p>这里需要用到 <a href="https://mirrors.openSUSE.org/list/bs.html" target="_blank" rel="noopener noreferrer">OBS(Open Build Service, 类似 arch 的 AUR，但是是预编译的包)</a>，因为 OBS 东西太多了，因此不存在完整的国内镜像，平均速度大概 300kb/s。
建议有条件可以在路由器上加智能代理提速。</p>
</blockquote>
<p>安装需要用到的各类软件:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启用 Packman 仓库，使用北交镜像源</span>
sudo zypper ar -cfp <span class="m">90</span> <span class="s1">&#39;https://mirror.bjtu.edu.cn/packman/suse/openSUSE_Tumbleweed/&#39;</span> packman-bjtu

<span class="c1"># install video player and web browser</span>
sudo zypper install mpv ffmpeg-4 chromium firefox

<span class="c1"># install screenshot and other utils</span>
<span class="c1"># 安装好后可以配个截图快捷键 alt+a =&gt; `flameshot gui`</span>
sudo zypper install flameshot peek nomacs

<span class="c1"># install git clang/make/cmake</span>
sudo zypper install git gcc clang make cmake

<span class="c1"># install wireshark</span>
sudo zypper install wireshark
sudo gpasswd --add <span class="nv">$USER</span> wireshark  <span class="c1">#  将你添加到 wireshark 用户组中</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="ide--编程语言">IDE + 编程语言</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># install vscode: https://en.openSUSE.org/Visual_Studio_Code</span>
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo zypper addrepo https://packages.microsoft.com/yumrepos/vscode vscode
sudo zypper refresh
sudo zypper install code

<span class="c1"># 安装 dotnet 5: https://docs.microsoft.com/en-us/dotnet/core/install/linux-openSUSE#openSUSE-15-</span>
sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
sudo zypper addrepo https://packages.microsoft.com/openSUSE/15/prod/ microsoft-prod
sudo zypper refresh
sudo zypper install dotnet-sdk-5.0

<span class="c1"># 安装新版本的 go（源中的版本比较低，更建议从 go 官网下载安装）</span>
sudo zypper install go
</code></pre></td></tr></table>
</div>
</div><p>通过 tarball/script 安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># rustup，rust 环境管理器</span>
curl --proto <span class="s1">&#39;=https&#39;</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="p">|</span> sh

<span class="c1"># jetbrains toolbox app，用于安装和管理 pycharm/idea/goland/android studio 等 IDE</span>
<span class="c1"># 参见：https://www.jetbrains.com/toolbox-app/</span>

<span class="c1"># 不使用系统 python，改用 miniconda 装 python3.8</span>
<span class="c1"># 参考：https://github.com/ContinuumIO/docker-images/blob/master/miniconda3/debian/Dockerfile</span>
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O /tmp/miniconda.sh
sudo /bin/bash /tmp/miniconda.sh -b -p /opt/conda
rm /tmp/miniconda.sh
sudo /opt/conda/bin/conda clean -tipsy
sudo ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh
<span class="nb">echo</span> <span class="s2">&#34;. /opt/conda/etc/profile.d/conda.sh&#34;</span> &gt;&gt; ~/.bashrc
<span class="nb">echo</span> <span class="s2">&#34;conda activate base&#34;</span> &gt;&gt; ~/.bashrc
<span class="c1"># miniconda 的 entrypoint 默认安装在如下目录，添加到 PATH 中</span>
<span class="nb">echo</span> <span class="s2">&#34;export PATH=\$PATH:\$HOME/.local/bin&#34;</span> &gt;&gt; ~/.bashrc
</code></pre></td></tr></table>
</div>
</div><p>接下来安装 VSCode 插件，下列是我的插件列表：</p>
<ol>
<li>语言：
<ol>
<li>python/go/rust/c#/julia/flutter</li>
<li>xml/yaml/toml</li>
<li>vscode proto3</li>
</ol>
</li>
<li>ansible/terraform</li>
<li>markdown all in one + Markdown Preview Enhanced</li>
<li>美化：
<ol>
<li>community material theme</li>
<li>vscode icons</li>
<li>glasslt-vsc</li>
</ol>
</li>
<li>docker/kubernetes</li>
<li>IntelliJ IDEA Keybindings</li>
<li>gitlens</li>
<li>prettier</li>
<li>utils
<ol>
<li>comment translate</li>
<li>path intellisense</li>
<li>svg</li>
<li>visual studio intellicode</li>
</ol>
</li>
<li>antlr4</li>
<li>remote ssh + remote containers</li>
<li>rest client</li>
<li>vscode databases</li>
</ol>
<h3 id="容器--kubernetes">容器 + Kubernetes</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 时髦的新容器套装: https://documentation.suse.com/sles/15-SP2/html/SLES-all/cha-podman-overview.html</span>
sudo zypper in podman kompose skopeo buildah katacontainers
<span class="c1"># 安装 kubernetes 相关工具，tumbleweed 官方仓库的包都非常新！很舒服</span>
sudo zypper in helm k9s kubernetes-client

<span class="c1"># 本地测试目前还是 docker-compose 最方便，docker 仍有必要安装</span>
sudo zypper in docker
sudo gpasswd --add <span class="nv">$USER</span> docker
sudo systemctl <span class="nb">enable</span> docker
sudo systemctl start docker

<span class="c1"># 简单起见，直接用 pip 安装 docker-compose 和 podman-compose</span>
sudo pip install docker-compose podman-compose
</code></pre></td></tr></table>
</div>
</div><h3 id="办公音乐聊天">办公、音乐、聊天</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 添加 openSUSE_zh 源：https://build.opensuse.org/project/show/home:opensuse_zh</span>
sudo zypper addrepo <span class="s1">&#39;https://download.opensuse.org/repositories/home:/opensuse_zh/openSUSE_Tumbleweed&#39;</span> openSUSE_zh
sudo zypper refresh
sudo zypper install wps-office netease-cloud-music

<span class="c1"># linux qq: https://im.qq.com/linuxqq/download.html</span>
<span class="c1"># 虽然简陋但也够用，发送文件比 KDE Connect 要方便一些。</span>
sudo rpm -ivh linux_qq.rpm
</code></pre></td></tr></table>
</div>
</div><h3 id="安装输入法">安装输入法</h3>
<p>我用的输入法是小鹤音形，首先安装 fcitx-rime:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 添加 m17n obs 源：https://build.openSUSE.org/repositories/M17N</span>
sudo zypper addrepo <span class="s1">&#39;https://download.opensuse.org/repositories/M17N/openSUSE_Tumbleweed&#39;</span> m17n
sudo zypper refresh
sudo zypper install fcitx5 fcitx5-configtool fcitx5-qt5 fcitx5-rime
</code></pre></td></tr></table>
</div>
</div><p>然后，从 <a href="http://flypy.ys168.com/">http://flypy.ys168.com/</a> 下载最新的鼠须管（MacOS）配置文件，将解压得到的 rime 文件夹拷贝到 ~/.local/share/fcitx5/ 下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mv rime ~/.local/share/fcitx5/
</code></pre></td></tr></table>
</div>
</div><p>现在重启系统，在 fcitx5 配置里面添加 rime「中州韵」，就可以正常使用小鹤音形了。</p>
<h3 id="qemukvm">QEMU/KVM</h3>
<p>不得不说，openSUSE 安装 KVM 真的超方便，纯 GUI 操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># see: https://doc.openSUSE.org/documentation/leap/virtualization/html/book-virt/cha-vt-installation.html</span>
sudo yast2 virtualization
<span class="c1"># enter to terminal ui, select kvm + kvm tools, and then install it.</span>
</code></pre></td></tr></table>
</div>
</div><p>KVM 的详细文档参见 <a href="../../virutal%20machine/KVM/README.md" rel="">KVM/README.md</a></p>
<h3 id="kde-connect">KDE Connect</h3>
<p>KDE Connect 是一个 PC 手机协同工具，可以在电脑和手机之间共享剪切版、远程输入、发送文件、共享文件夹、通知同步等等。
总而言之非常好用，只要手机和 PC 处于同一个局域网就行，不需要什么数据线。</p>
<p>如果安装系统时选择了打开防火墙，KDE Connect 是连不上的，需要手动开放端口号：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># see: https://userbase.kde.org/KDEConnect#firewalld</span>
sudo firewall-cmd --zone<span class="o">=</span>public --permanent --add-port<span class="o">=</span>1714-1764/tcp
sudo firewall-cmd --zone<span class="o">=</span>public --permanent --add-port<span class="o">=</span>1714-1764/udp
sudo systemctl restart firewalld.service
</code></pre></td></tr></table>
</div>
</div><p>然后手机（Android）安装好 KDE Connect，就能开始享受了。</p>
<p>目前存在的 Bug:</p>
<ul>
<li><i class="far fa-square fa-fw"></i> Android 10 禁止了后台应用读取剪切版，这导致 KDE Connect 只能从 PC 同步到手机，而无法反向同步。
<ul>
<li>如果你有 ROOT 权限，可以参考 <a href="https://szclsya.me/posts/android/fix-clipboard-android-10/" target="_blank" rel="noopener noreferrer">Fix clipboard permission on Android 10</a> 的方法，安装 ClipboardWhitelist 来打开权限。</li>
<li>否则，貌似就只能使用手机端的「远程输入」模块来手动传输文本了。</li>
</ul>
</li>
</ul>
<h3 id="qv2ray-代理">Qv2ray 代理</h3>
<p>Qv2ray 是我用过的比较好用的 GUI 代理工具，通过插件可支持常见的所有代理协议。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># see: https://build.openSUSE.org/repositories/home:zzndb</span>
sudo zypper addrepo <span class="s1">&#39;https://download.opensuse.org/repositories/home:/zzndb/openSUSE_Tumbleweed&#39;</span> qv2ray
sudo zypper refresh
sudo zypper install Qv2ray QvPlugin-Trojan QvPlugin-SS
</code></pre></td></tr></table>
</div>
</div><h3 id="vpn-连接与防火墙">VPN 连接与防火墙</h3>
<p>防火墙默认会禁用 pptp 等 vpn 协议的端口，需要手动打开.</p>
<p>允许使用 PPTP 协议：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 允许 gre 数据包流入网络</span>
sudo firewall-cmd --permanent --zone<span class="o">=</span>public --direct --add-rule ipv4 filter INPUT <span class="m">0</span> -p gre -j ACCEPT
sudo firewall-cmd --permanent --zone<span class="o">=</span>public --direct --add-rule ipv6 filter INPUT <span class="m">0</span> -p gre -j ACCEPT

<span class="c1"># masquerade: 自动使用 interface 地址伪装所有流量（将主机当作路由器使用，vpn 是虚拟网络，需要这个功能）</span>
sudo firewall-cmd --permanent --zone<span class="o">=</span>public --add-masquerade
<span class="c1"># pptp 客户端使用固定端口 1723/tcp 通信</span>
firewall-cmd --add-port<span class="o">=</span>1723/tcp --permanent

sudo firewall-cmd --reload
</code></pre></td></tr></table>
</div>
</div><p>允许使用 wireguard 协议，此协议只使用 tcp 协议，而且可以端口号可以自定义。不过 wireguard 自身的配置文件 <code>/etc/wireguard/xxx.conf</code> 就能配置 iptables 参数放行相关端口，这里就不赘述了。</p>
<h2 id="其他设置">其他设置</h2>
<p>从 Windows 带过来的习惯是单击选中文件，双击才打开，这个可以在「系统设置」-「工作空间行为」-「常规行为」-「点击行为」中修改。</p>]]></description></item><item><title>Manjaro 使用指南</title><link>https://ryan4yin.space/posts/manjaro-instruction/</link><pubDate>Sat, 13 Jul 2019 20:38:24 +0800</pubDate><author>
ryan4yin</author><guid>https://ryan4yin.space/posts/manjaro-instruction/</guid><description><![CDATA[<p>Manjaro 是一个基于 Arch Linux 的 Linux 滚动发行版，用着挺舒服的。
最大的特点，是包仓库很丰富，而且都很新。代价是偶尔会出些小毛病。</p>
<p>我一年多的使用中，遇到过 qv2-ray 动态链接库炸掉的问题，没专门去找修复方法，好像是等了一两个月，升级了两个大版本才恢复。
另一个就是 <a href="https://github.com/microsoft/vscode/issues/110322" target="_blank" rel="noopener noreferrer">VSCode - Incorrect locale &lsquo;en-US&rsquo; used everywhere</a></p>
<p>还遇到过 <code>libguestfs</code> 的一个问题：<code>vrit-v2v</code>/<code>virt-p2v</code> 两个工具被拆分出去，导致 manjaro 只能通过源码安装这俩货。这貌似目前仍旧没有解决。</p>
<p>总的来说体验很不错，能很及时地用上各种新版本的软件。</p>
<h2 id="一pacmanyay-的基础命令">一、pacman/yay 的基础命令</h2>
<p>Manjaro 装好后，需要运行的第一条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">sudo pacman -Syy <span class="c1">## 强制更新 package 目录</span>
sudo pacman-mirrors --interactive --country China  <span class="c1"># 列出所有国内的镜像源，并提供交互式的界面手动选择镜像源</span>
sudo pacman -Syyu  <span class="c1"># 强制更新 package 目录，并尝试更新已安装的所有 packages.</span>
sudo pacman -S yay  <span class="c1"># 安装 yay</span>
</code></pre></td></tr></table>
</div>
</div><p>pacman 是 arch/manjaro 的官方包管理器，而刚刚安装的 yay，则是一个能查询 arch linux 的 aur 仓库的第三方包管理器，非常流行。</p>
<p>pacman 的常用命令语法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">pacman -S package_name        <span class="c1"># 安装软件  </span>
pacman -S extra/package_name  <span class="c1"># 安装不同仓库中的版本</span>
pacman -Syu                   <span class="c1"># 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件</span>
pacman -Ss string             <span class="c1"># 在包数据库中查询软件</span>
pacman -Si package_name       <span class="c1"># 显示软件的详细信息</span>
pacman -Sc                    <span class="c1"># 清除软件缓存，即/var/cache/pacman/pkg目录下的文件</span>
pacman -R package_name        <span class="c1"># 删除单个软件</span>
pacman -Rs package_name       <span class="c1"># 删除指定软件及其没有被其他已安装软件使用的依赖关系</span>
pacman -Qs string             <span class="c1"># 查询已安装的软件包</span>
pacman -Qi package_name       <span class="c1"># 查询本地安装包的详细信息</span>
pacman -Ql package_name       <span class="c1"># 获取已安装软件所包含的文件的列表</span>
pacman -U package.tar.zx      <span class="c1"># 从本地文件安装</span>
pactree package_name          <span class="c1"># 显示软件的依赖树</span>
</code></pre></td></tr></table>
</div>
</div><p>yay 的用法和 pacman 完全类似，上述所有 <code>pacman xxx</code> 命令，均可替换成 <code>yay xxx</code> 执行。</p>
<p>此外，还有一条 <code>yay</code> 命令值得记一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">yay -c  <span class="c1"># 卸载所有无用的依赖。类比 apt-get autoremove</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="常用软件与配置">常用软件与配置</h2>
<h3 id="1-添加-archlinux-中文社区仓库">1. 添加 archlinux 中文社区仓库</h3>
<p><a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener noreferrer">Arch Linux 中文社区仓库</a> 是由 Arch Linux 中文社区驱动的非官方用户仓库，包含一些额外的软件包以及已有软件的 git 版本等变种。部分软件包的打包脚本来源于 AUR。</p>
<p>一些国内软件，如果直接从 aur 安装，那就会有一个编译过程，有点慢。而 archlinuxcn 有已经编译好的包，可以直接安装。更新速度也很快，推荐使用。</p>
<p>配置方法见 <a href="https://github.com/archlinuxcn/repo" target="_blank" rel="noopener noreferrer">Arch Linux Chinese Community Repository</a>。</p>
<h3 id="2-安装常用软件">2. 安装常用软件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">sudo pacman -S google-chrome  firefox         <span class="c1"># 浏览器</span>
sudo pacman -S netease-cloud-music     <span class="c1"># 网易云音乐</span>
sudo pacman -S noto-fonts-cjk wqy-bitmapfont wqy-microhei wqy-zenhei   <span class="c1"># 中文字体：思源系列、文泉系列</span>
sudo pacman -S wps-office ttf-wps-fonts

sudo pacman -S vim                     <span class="c1"># 命令行编辑器</span>
sudo pacman -S git                     <span class="c1"># 版本管理工具</span>
sudo pacman -S clang make cmake gdb    <span class="c1"># 编译调试环境</span>
sudo pacman -S visual-studio-code-bin  <span class="c1"># 代码编辑器</span>

sudo pacman -S wireshark-qt  mitmproxy         <span class="c1"># 抓包工具</span>
sudo pacman -S docker  <span class="c1"># docker 容器</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 docker 和 wireshark 需要额外配置，否则会要求管理员权限：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sh" data-lang="sh">sudo groupadd wireshark
sudo gpasswd --add <span class="nv">$USER</span> wireshark  <span class="c1">#  将你添加到 wireshark 用户组中</span>

sudo groupadd docker
sudo gpasswd --add <span class="nv">$USER</span> docker  <span class="c1"># 同上</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="3-中文输入法">3. 中文输入法</h3>
<p>有两个选择：<a href="https://rime.im/" target="_blank" rel="noopener noreferrer">中州韵（rime）</a>和<a href="https://aur.archlinux.org/packages/fcitx-sogoupinyin/" target="_blank" rel="noopener noreferrer">搜狗拼音（sogoupinyin）</a>。</p>
<p>简单省事用搜狗，要用特殊的输入方案（五笔、音形、二笔等等）就只有 rime 可选了。</p>
<h4 id="31-fcitx5-rime-配置小鹤音形">3.1 fcitx5-rime 配置小鹤音形</h4>
<p>首先安装 fcitx5-rime, 注意这些组件一个都不能省略：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sudo pacman -S fcitx5  fcitx5-chinese-addons fcitx5-gtk  fcitx5-qt  kcm-fcitx5 fcitx5-rime
</code></pre></td></tr></table>
</div>
</div><p>第二步是修改环境变量，将 fcitx5-rime 设为默认输入法并自动启动。</p>
<p>添加 <code>~/.pam_environment</code> 文件，内容如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">INPUT_METHOD  DEFAULT=fcitx5
GTK_IM_MODULE DEFAULT=fcitx5
QT_IM_MODULE  DEFAULT=fcitx5
XMODIFIERS    DEFAULT=@im=fcitx5
</code></pre></td></tr></table>
</div>
</div><p><a href="https://wiki.archlinux.org/index.php/PAM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreferrer">pam-env</a> 模块会在所有登录会话中读取上面的配置文件，包括 X11 会话和 Wayland 会话。</p>
<p>添加自动启动：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># ~/.xprofile 是 x11 GUI 的环境变量配置文件</span>
<span class="nb">echo</span> <span class="s1">&#39;fcitx5 &amp;&#39;</span> &gt;&gt; ~/.xprofile
</code></pre></td></tr></table>
</div>
</div><p>然后，从 <a href="http://flypy.ys168.com/">http://flypy.ys168.com/</a> 下载最新的鼠须管（MacOS）配置文件，将解压得到的 rime 文件夹拷贝到 ~/.local/share/fcitx5/ 下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mv rime ~/.local/share/fcitx5/
</code></pre></td></tr></table>
</div>
</div><p>现在重启系统，在 fcitx5 配置里面添加 rime，就可以正常使用小鹤音形了。</p>
<h2 id="坑">坑</h2>
<p>使用过程中，我也遇到了一些坑：</p>
<ol>
<li>安装软件包时，无法在线安装旧版本！除非你本地有旧版本的安装包没清除，才可以通过缓存安装旧版本。
<ul>
<li>这种问题没遇到时好说，但有时候新版本有问题，旧安装包也清理掉了无法回退，就非常麻烦。</li>
<li>而且就算你回退了版本，一升级它就又更新了。。</li>
</ul>
</li>
</ol>
<h2 id="彻底删除-manjaro-及其引导项">彻底删除 Manjaro 及其引导项</h2>
<p>最近(2021-01)切换到了 OpenSUSE，体验很好，于是决定删除掉 Manjaro。</p>
<p>一番操作，总结出的删除流程如下（以下命令均需要 root 权限）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 1. 删除 EFI 引导项</span>
<span class="c1">## 查看 efi 的所有启动项，找到 Manjaro 的编号</span>
efibootmgr
<span class="c1">## 删除掉 Manjaro 启动项</span>
sudo efibootmgr --delete-bootnum -b <span class="m">2</span>

<span class="c1"># 2. 删除 manjaro 的 bootloader</span>
<span class="c1">## 我使用了 manjaro 默认的安装策略，bootloader 被安装在了和 windows 相同的 EFI 分区下</span>
<span class="c1">## 首先通过 opnsuse 的分区工具，找到 EFI 分区的设备号，然后挂载它</span>
mkdir efi
mount /dev/nvme0n1p1 efi
<span class="c1"># 删除 Manjaro bootloader</span>
rm -r EFI/Manjaro

<span class="c1"># 3. 重建 grub2 引导项</span>
grub2-mkconfig &gt;  /boot/grub2/grub.cfg

<span class="c1"># 4. 最后，通过分区工具删除 Manjaro 的所有分区，我是 SSD，只有一个分区</span>

<span class="c1"># 5. 重启系统，所有东西就全删除干净了。</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Main_page_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreferrer">Arch Linux Wiki - 中文</a></li>
<li><a href="https://aur.archlinux.org/packages" target="_blank" rel="noopener noreferrer">AUR 仓库</a></li>
<li><a href="https://www.archlinuxcn.org/archlinux-cn-repo-and-mirror/" target="_blank" rel="noopener noreferrer">Arch Linux 中文社区仓库</a></li>
<li><a href="https://github.com/Jguer/yay" target="_blank" rel="noopener noreferrer">yay - Yet another Yogurt - An AUR Helper written in Go </a></li>
<li><a href="https://panqiincs.me/2019/06/05/after-installing-manjaro/" target="_blank" rel="noopener noreferrer">安装Manjaro之后的配置 </a></li>
<li><a href="https://wiki.archlinux.org/index.php/Fcitx5_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener noreferrer">Arch Linux Wiki - Fcitx5</a></li>
</ul>]]></description></item></channel></rss>